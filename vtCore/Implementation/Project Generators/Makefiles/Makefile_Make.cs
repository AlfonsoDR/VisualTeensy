using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Linq;
using vtCore.Interfaces;
using System.Drawing;

namespace vtCore
{
    static internal class Makefile_Make
    {
        static public string generate(IProject project, LibManager libManager, SetupData setup)
        {
            var cfg = project.selectedConfiguration;
            if (!cfg.isOk) return "ERROR";
            //if (cfg.setupType == SetupTypes.quick && (setup.arduinoBaseError != null)) return "Error: Arduino path not set!\n\nPlease switch to expert setup or define a \nvalid Arduino path in the Settings tab.";
            //if (cfg.setupType == SetupTypes.expert && !cfg.compilerBase.isOk) return "Error: Compiler path not set!";
            //if (cfg.setupType == SetupTypes.expert && !cfg.coreBase.isOk) return "Error: Hardware folder (folder containing boards.txt and the cores subfolder) is not set";
            var board = cfg.selectedBoard;
            //if (board == null) return "Error: No board selected";

            var options = board.getAllOptions();

            StringBuilder mf = new StringBuilder();

            mf.Append("#******************************************************************************\n");
            mf.Append("# Generated by VisualTeensy (https://github.com/luni64/VisualTeensy)\n");
            mf.Append("#\n");
            mf.Append($"# {"Board",-18} {board.name}\n");
            foreach (var o in board.optionSets)
            {
                mf.Append($"# {o.name,-18} {o.selectedOption?.name}\n");
            }
            mf.Append("#\n");
            mf.Append($"# {DateTime.Now.ToShortDateString()} {DateTime.Now.ToShortTimeString()}\n");
            mf.Append("#******************************************************************************\n");

            mf.Append($"SHELL            := cmd.exe\nexport SHELL\n\n");
            mf.Append($"TARGET_NAME      := {project.cleanName}\n");
            mf.Append(makeEntry("BOARD_ID         := ", "build.board", options) + "\n\n");
            mf.Append(makeEntry("MCU              := ", "build.mcu", options) + "\n\n");

            mf.Append($"LIBS_SHARED_BASE := {Helpers.getShortPath(libManager.sharedRepository.repoPath)}\n");
            mf.Append($"LIBS_SHARED      := ");
            foreach (var lib in cfg.sharedLibs)
            {
                mf.Append($"{lib.sourceFolderName ?? "ERROR"} ");
            }
            mf.Append("\n\n");

            mf.Append($"LIBS_LOCAL_BASE  := lib\n");
            mf.Append($"LIBS_LOCAL       := ");
            foreach (var lib in cfg.localLibs)
            {
                mf.Append($"{lib.targetFolderName} ");
            }
            mf.Append("\n\n");

            //mf.Append($"CORE_BASE        := {Helpers.getShortPath(Path.Combine(setup.arduinoCoreBase ?? "Error", "cores", cfg.selectedBoard.core))}\n");

            if (cfg.setupType == SetupTypes.quick)
            {
                mf.Append($"CORE_BASE        := {Helpers.getShortPath(Path.Combine(setup.arduinoCoreBase ?? "Error", "cores", cfg.selectedBoard.core))}\n");
                mf.Append($"GCC_BASE         := {cfg.compiler}\n");
                mf.Append($"UPL_PJRC_B       := {Helpers.getShortPath(setup.arduinoTools)}\n");             
            }
            else
            {
                mf.Append($"CORE_BASE        := {((cfg.copyCore || (Path.GetDirectoryName(cfg.coreBase.path) == project.path)) ? "core" : Helpers.getShortPath(cfg.core))}\n");
                mf.Append($"GCC_BASE         := {cfg.compiler}\n");
                if (!String.IsNullOrWhiteSpace(setup.uplPjrcBase.path)) mf.Append($"UPL_PJRC_B       := {setup.uplPjrcBase.shortPath}\n");
                //mf.Append($"UPL_PJRC_B       := {setup.uplPjrcBase.shortPath}\n");
            }
            if (!String.IsNullOrWhiteSpace(setup.uplTyBase.path)) mf.Append($"UPL_TYCMD_B      := {setup.uplTyBase.shortPath}\n");
            if (!String.IsNullOrWhiteSpace(setup.uplJLinkBase.path)) mf.Append($"UPL_JLINK_B      := {setup.uplJLinkBase.shortPath}\n");
            if (project.debugSupport != DebugSupport.none && !String.IsNullOrWhiteSpace(setup.uplCLIBase.path)) mf.Append($"UPL_CLICMD_B     := {setup.uplCLIBase.shortPath}\n");


            mf.Append("\n#******************************************************************************\n");
            mf.Append("# Flags and Defines\n");
            mf.Append("#******************************************************************************\n");

            mf.Append(makeEntry("FLAGS_CPU   := ", "build.flags.cpu", options) + "\n");
            mf.Append(makeEntry("FLAGS_OPT   := ", "build.flags.optimize", options) + "\n");
            mf.Append(makeEntry("FLAGS_COM   := ", "build.flags.common", options) + makeEntry(" ", "build.flags.dep", options) + "\n");
            mf.Append(makeEntry("FLAGS_LSP   := ", "build.flags.ldspecs", options) + "\n");

            mf.Append("\n");
            mf.Append(makeEntry("FLAGS_CPP   := ", "build.flags.cpp", options) + "\n");
            mf.Append(makeEntry("FLAGS_C     := ", "build.flags.c", options) + "\n");
            mf.Append(makeEntry("FLAGS_S     := ", "build.flags.S", options) + "\n");

            mf.Append(makeEntry("FLAGS_LD    := ", "build.flags.ld", options).Replace("{build.core.path}", "$(CORE_BASE)") + "\n");

            mf.Append("\n");
            mf.Append(makeEntry("LIBS        := ", "build.flags.libs", options) + "\n");
            //mf.Append(makeEntry("LD_SCRIPT   := ", "build.mcu", options) + ".ld\n");

            mf.Append("\n");
            mf.Append(makeEntry("DEFINES     := ", "build.flags.defs", options) + " -DARDUINO=10807\n");
            mf.Append("DEFINES     += ");
            mf.Append(makeEntry("-DF_CPU=", "build.fcpu", options) + " " + makeEntry("-D", "build.usbtype", options) + " " + makeEntry("-DLAYOUT_", "build.keylayout", options) + "\n");

            mf.Append($"\n");
            mf.Append("CPP_FLAGS   := $(FLAGS_CPU) $(FLAGS_OPT) $(FLAGS_COM) $(DEFINES) $(FLAGS_CPP)\n");
            mf.Append("C_FLAGS     := $(FLAGS_CPU) $(FLAGS_OPT) $(FLAGS_COM) $(DEFINES) $(FLAGS_C)\n");
            mf.Append("S_FLAGS     := $(FLAGS_CPU) $(FLAGS_OPT) $(FLAGS_COM) $(DEFINES) $(FLAGS_S)\n");
            mf.Append("LD_FLAGS    := $(FLAGS_CPU) $(FLAGS_OPT) $(FLAGS_LSP) $(FLAGS_LD)\n");
            mf.Append("AR_FLAGS    := rcs\n");

            if (cfg.setupType == SetupTypes.expert && !String.IsNullOrWhiteSpace(cfg.makefileExtension))
            {
                mf.Append("\n");
                mf.Append(cfg.makefileExtension);
                mf.Append("\n");
            }

            mf.Append("\n#******************************************************************************\n");
            mf.Append("# Colors\n");
            mf.Append("#******************************************************************************\n");
            if (setup.isColoredOutput)
            {
                mf.Append($"COL_CORE    := {colEsc(setup.colorCore)}\n");
                mf.Append($"COL_LIB     := {colEsc(setup.colorUserLib)}\n");
                mf.Append($"COL_SRC     := {colEsc(setup.colorUserSrc)}\n");
                mf.Append($"COL_LINK    := {colEsc(setup.colorLink)}\n");
                mf.Append($"COL_ERR     := {colEsc(setup.colorErr)}\n");
                mf.Append($"COL_OK      := {colEsc(setup.colorOk)}\n");
                mf.Append($"COL_RESET   := {colReset}\n");
            }
            else
            {
                mf.Append($"COL_CORE    := {colReset}\n");
                mf.Append($"COL_Lib     := {colReset}\n");
                mf.Append($"COL_SRC     := {colReset}\n");
                mf.Append($"COL_LINK    := {colReset}\n");
                mf.Append($"COL_ERR     := {colReset}\n");
                mf.Append($"COL_OK      := {colReset}\n");
                mf.Append($"COL_RESET   := {colReset}\n");
            }

            mf.Append("\n");
            mf.Append(setup.makefile_fixed);

            return mf.ToString();
        }

        private static string makeEntry(String txt, String key, Dictionary<String, String> options)
        {
            return options.ContainsKey(key) ? $"{txt}{options[key]}" : "";
        }

        private static string colEsc(Color c)
        {            
            return $"{(char)27}[38;2;{c.R};{c.G};{c.B}m";
        }

        private static string colReset = $"{(char)27}[0m";
    }
}

